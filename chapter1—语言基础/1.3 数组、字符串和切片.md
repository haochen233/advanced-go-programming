## 1.3 数组、字符串和切片
在主流的编程语言中数组及其相关的数据结构是使用得最为频繁的。

首先，Go语言的数组是一种值类型，虽然数组的元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理的。

Go语言字符串底层数据也是对应的字节数组，但是字符串的只读属性禁止了在程序中对底层字节数组的元素的修改。字符串赋值只是复制了数据地址和对应的长度，而不会导致底层数据的复制。

切片的行为更为灵活，切片的结构和字符串结构类似，但是解除了只读限制。切片的底层数据虽然也是对应数据类型的数组，但是每个切片还有独立的长度和容量信息，切片赋值和函数传参数时也是将切片头信息部分按传值方式处理。因为切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制。

其实Go语言的赋值和函数传参规则很简单，除了闭包函数以引用的方式对外部变量访问之外，其它赋值和函数传参数都是以传值的方式处理。

### 1.3.1 数组
数组的定义方式:  
```go
var arr1 [5]int //长度为5的int数组，元素默认值为0。
var arr1 = [5]int{} //长度为5的int数组，元素默认值为0。
var arr1 = [...]int{} //长度为0的int数组
var arr1 = [...]int{2:1, 4:6} //长度以指定的最大下标置为准的int数组，即长度为5，且下标为2元素初值为1，下标为4元素初值为6，其余元素初值为0。
var arr1 = [5]int{1,2,3,4,5} //长度为5的int数组，初值分别为1，2，3，4，5
var arr1 = [10]int{1,2,3,4,5} //长度为10的int数组，前5个元素初值分别为1，2，3，4，5；其余元素为0
var arr1 = [10]int{1:2, 3:4} //长度为10的int数组，下标为1的元素初值为2，下标为3的元素初值为4；其余元素初值为0。
var arr1 = [0]int{} //长度为0的int数组。
var arr1 [0]int //长度为0的int数组。
```

当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组。如果数组比较大的话，数组的赋值也会有较大的开销。为了避免复制数组带来的开销，可以传递一个指向数组的指针，但是数组指针并不是数组。

下例b是a的数组指针：  
```go
	var a = [...]int{1,2,3}
	var b = &a

	for _,v := range a{
		fmt.Println(v)
	}

	for _,v := range b{
		fmt.Println(v)
	}

	fmt.Println(a)
	fmt.Println(b)

/*for range遍历的结果是一样的，a是数组类型，b是数组指针类型。*/
```

数组指针操作数组的方式和通过数组本身的操作类似，而且数组指针赋值时只会拷贝一个指针。 

但是数组指针类型依然不够灵活，因为数组的长度是数组类型的组成部分，指向不同长度数组的数组指针类型也是完全不同的。

可以将数组看作一个特殊的结构体，结构的字段名对应数组的索引，同时结构体成员的数目是固定的。

内置函数len可以用于计算数组的长度，cap函数可以用于计算数组的容量。不过对于数组类型来说，len和cap函数返回的结果始终是一样的，都是对应数组类型的长度。

长度为0的数组的使用：
1. 空数组进行方便的迭代
用for range方式迭代，还可以忽略迭代时的下标:  
```go
var times [5][0]int 
for range times {
    fmt.Println("hello")
}
/*上例times是一个第一纬长度为5，第二维长度为0的二维数组，所占内存空间为0，所以可以利用failure数组和for range来进行方便的迭代。上例进行了5次迭代。*/
```

2. 空数组用于管道的同步
在管道的同步操作时，可以传递空数组来进行同步，可以避免额外的内存空间。例如：  
```go
c1 := make(chan [0]int) //定义类型为空int数组类型的阻塞式管道
go func(){
    fmt.Println("hello world!")
    c1 <- [0]int{}  //将这个空数组塞进管道
}
//主函数从管道取
<- c1

/*这样的同步操作，避免了额外的内存分配*/
```

在这里，我们并不关心管道中传输数据的真是类型，其中管道接收和发送操作只是用于消息的同步。对于这种场景，我们用空数组来作为管道类型可以减少管道元素赋值时的开销。当然一般更倾向于用无类型的匿名结构体代替：  
```go
c1 := make(chan struct{}) //定义一个类型为空结构体类型的阻塞式管道。
go func(){
    fmt.Println("hello world!")
    c1 <- struct{}{}  //将这个空结构体塞进管道（即匿名空结构体定义的变量）
}
//主函数从管道取
<- c1

```

### 1.3.2 字符串
一个字符串是一个不可改变的字节序列，字符串通常是用来包含人类可读的文本数据。和数组不同的是，字符串的元素不可修改，是一个只读的字节数组。每个字符串的长度虽然也是固定的，但是字符串的长度并不是字符串类型的一部分。

字符串虽然不是切片，但是支持切片操作，不同位置的切片底层也访问的同一块内存数据（因为字符串是只读的，相同的字符串面值常量通常是对应同一个字符串常量）：  
```go
s := "hello world"  //s是字符串
hello := s[:5]      //hello是基于s的切片
world := s[6:]      //world是基于s的切片

s1 := "hello world"[:5] //s1是关于"hello world"字符串的切片。
s2 := "hello world"[6:] //s2是关于"hello world"字符串的切片。
```

### 1.3.3 切片（slice）
切片的定义方式有两种：
1. 基于底层数组  
```go
var arr = [5]int{1,2,3,4,5} //底层数组
s []int   //空切片
s := []int{} //空切片
s := []int{1,2,3} //有三个元素的切片
s := arr  //s是对整个arr数组的引用
s := arr[:] //s是对整个arr数组的引用
s := arr[0:len(arr)] //s是对整个arr数组的引用
s := arr[1:4] //s是数组arr下标1到下标3的引用
```

注意`s := []int{1,2,3}`和`a := [...]int{1,2,3}`前面是切片后面是数组。
2. 使用make创建
```go
s := make([]int, 2) //长度为2的切片
s := make([]int, 2, 3) //长度为2，容量为3的切片

```

切片的遍历方式与数组相同

**添加切片元素**
内置的泛型函数append可以在切片的尾部追加N个元素：  
```go
var a []int
a = append(a, 1)
a = append(a, 2, 3, 4)
a = append(a, []int{1,2,3}...) 

```
不过要注意的是，在容量不足的情况下，append的操作会导致重新分配内存，可能导致巨大的内存分配和复制数据代价。即使容量足够，依然需要用append函数的返回值来更新切片本身，因为新切片的长度已经发生了变化。  

还可以在切片的头部添加元素：  
```go
a = append([]int{0}, a...) //在a切片的前面添加元素0
```

关于Go语言中`...`的用法：  
- 函数不定长参数的声明；例如： func sum(args ...int),这是任意个int相加的函数声明。  
- 在调用有不定长参数的函数时，可以将对应类型的切片打散作为不定长参数；例如：  
```go
var slice = []int{1,2,3,4,5,6,7}
sum(slice...)   //因为参数要求是任意个不定长的int类型，所以使用...将slice打散作为参数传递。
```

在开头一般都会导致内存的重新分配，而且会导致已有的元素全部复制1次。因此，从切片的开头添加元素的性能一般要比从尾部追加元素的性能差很多。

由于append函数返回新的切片，也就是它支持链式操作。我们可以将多个append操作组合起来，实现在切片中间插入元素：  
```go
a = append(a[:5], append([]int{666}, a[5:]...)...) //在下标为5的位置插入666
```

**删除切片元素**
根据要删除元素的位置有三种情况：从开头位置删除，从中间位置删除，从尾部删除。其中删除切片尾部的元素最快：  
1. 从尾部删
```go
s := []int{1,2,3,4,5,6,7,8,9}
s = s[:len(s)-1] //删除尾部的1个元素
s = s[:len(s)-n] //删除尾部的n个元素
```
2. 从头删可以直接移动数据指针
```go
s = s[1:] //删除头部的一个元素
s = s[n:] //删除头部的n个元素
```
删除开头的元素也可以不移动数据指针，但是将后面的数据向开头移动。可以用append原地完成（所谓原地完成是指在原有的切片数据对应的内存区间内完成，不会导致内存空间结构的变化）：  
```go
s = append(a[:0], a[1:]...) //从头部删除1个
s = append(a[:0], a[n:]...) //从头部删除n个
```  
还可以使用`copy`删除开头的元素：  
```go

```
