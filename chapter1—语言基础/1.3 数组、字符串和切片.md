## 1.3 数组、字符串和切片
在主流的编程语言中数组及其相关的数据结构是使用得最为频繁的。

首先，Go语言的数组是一种值类型，虽然数组的元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理的。

Go语言字符串底层数据也是对应的字节数组，但是字符串的只读属性禁止了在程序中对底层字节数组的元素的修改。字符串赋值只是复制了数据地址和对应的长度，而不会导致底层数据的复制。

切片的行为更为灵活，切片的结构和字符串结构类似，但是解除了只读限制。切片的底层数据虽然也是对应数据类型的数组，但是每个切片还有独立的长度和容量信息，切片赋值和函数传参数时也是将切片头信息部分按传值方式处理。因为切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制。

其实Go语言的赋值和函数传参规则很简单，除了闭包函数以引用的方式对外部变量访问之外，其它赋值和函数传参数都是以传值的方式处理。

### 1.3.1 数组
数组的定义方式:  
```go
var arr1 [5]int //长度为5的int数组，元素默认值为0。
var arr1 = [5]int{} //长度为5的int数组，元素默认值为0。
var arr1 = [...]int{} //长度为0的int数组
var arr1 = [...]int{2:1, 4:6} //长度以指定的最大下标置为准的int数组，即长度为5，且下标为2元素初值为1，下标为4元素初值为6，其余元素初值为0。
var arr1 = [5]int{1,2,3,4,5} //长度为5的int数组，初值分别为1，2，3，4，5
var arr1 = [10]int{1,2,3,4,5} //长度为10的int数组，前5个元素初值分别为1，2，3，4，5；其余元素为0
var arr1 = [10]int{1:2, 3:4} //长度为10的int数组，下标为1的元素初值为2，下标为3的元素初值为4；其余元素初值为0。
var arr1 = [0]int{} //长度为0的int数组。
var arr1 [0]int //长度为0的int数组。
```

当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组。如果数组比较大的话，数组的赋值也会有较大的开销。为了避免复制数组带来的开销，可以传递一个指向数组的指针，但是数组指针并不是数组。

下例b是a的数组指针：  
```go
	var a = [...]int{1,2,3}
	var b = &a

	for _,v := range a{
		fmt.Println(v)
	}

	for _,v := range b{
		fmt.Println(v)
	}

	fmt.Println(a)
	fmt.Println(b)

/*for range遍历的结果是一样的，a是数组类型，b是数组指针类型。*/
```

数组指针操作数组的方式和通过数组本身的操作类似，而且数组指针赋值时只会拷贝一个指针。 

但是数组指针类型依然不够灵活，因为数组的长度是数组类型的组成部分，指向不同长度数组的数组指针类型也是完全不同的。

可以将数组看作一个特殊的结构体，结构的字段名对应数组的索引，同时结构体成员的数目是固定的。

内置函数len可以用于计算数组的长度，cap函数可以用于计算数组的容量。不过对于数组类型来说，len和cap函数返回的结果始终是一样的，都是对应数组类型的长度。

长度为0的数组的使用：
1. 空数组进行方便的迭代
用for range方式迭代，还可以忽略迭代时的下标:  
```go
var times [5][0]int 
for range times {
    fmt.Println("hello")
}
/*上例times是一个第一纬长度为5，第二维长度为0的二维数组，所占内存空间为0，所以可以利用failure数组和for range来进行方便的迭代。上例进行了5次迭代。*/
```

2. 空数组用于管道的同步
在管道的同步操作时，可以传递空数组来进行同步，可以避免额外的内存空间。例如：  
```go
c1 := make(chan [0]int) //定义类型为空int数组类型的阻塞式管道
go func(){
    fmt.Println("hello world!")
    c1 <- [0]int{}  //将这个空数组塞进管道
}
//主函数从管道取
<- c1

/*这样的同步操作，避免了额外的内存分配*/
```

在这里，我们并不关心管道中传输数据的真是类型，其中管道接收和发送操作只是用于消息的同步。对于这种场景，我们用空数组来作为管道类型可以减少管道元素赋值时的开销。当然一般更倾向于用无类型的匿名结构体代替：  
```go
c1 := make(chan struct{}) //定义一个类型为空结构体类型的阻塞式管道。
go func(){
    fmt.Println("hello world!")
    c1 <- struct{}{}  //将这个空结构体塞进管道（即匿名空结构体定义的变量）
}
//主函数从管道取
<- c1

```

***

### 1.3.2 字符串
一个字符串是一个不可改变的字节序列，字符串通常是用来包含人类可读的文本数据。和数组不同的是，字符串的元素不可修改，是一个只读的字节数组。每个字符串的长度虽然也是固定的，但是字符串的长度并不是字符串类型的一部分。

Go语言字符串的底层结构在`reflect.stringHeader`中定义：
```go
type StringHeader struct{
    Data uintptr
    len int
}
```  
可以看出字符串结构由两个信息组成：第一个是字符串指向的底层字节数组，第二个是字符串的字节的长度。  
字符串其实是一个结构体，因此字符串的赋值操作也就是`reflect.StringHeader`结构体的复制过程，并不会涉及底层字节数组的复制  

**[]byte(s)转换模拟实现**
```go
//将字符串转换为字节切片
func strtosbytes(s string) []byte{
    p := make([]byte, len(s))
    for i, c := range s{
        b := c      //为了保证字符串只读的语义，更安全
        p[i] = b
    }
}
```

**string(bytes)转换模拟实现**
```go
//将字节切片转换为字符串
func bytestostr(s []byte) (p string){
    data := make([]byte, len(s))
    for i, c := range s{
        data[i] = c
    }

    //hdr 是指向字符串p的指针
    hdr := (*reflect.StringHeader)(unsafe.Pointer(&p))
    hdr.Date = uintptr(unsafe.Pointer(&p))
    hdr.Len = len(s)

    //因为字符串是只读的，无法直接通过构造字节数组
	//生成字符串。在模拟实现中通过unsafe包获取了字符串
	//底层数据结构，然后将切片的数据逐一复制到了字符串
	//中，这同样是为了保证字符串只读的语义不会受切片的
	//影响

    return p
}
```

**[]rune(s)转换模拟实现**
```go
func strtorunes(s string) []rune{
	var p []rune

	for len(s) > 0 {
		r, size := utf8.DecodeRuneInString(s)
		p = append(p, int32(r))
		//每转换一个处一个rune字符，字符串长度就对应减少对应的长度
		//即从头删除
		s = s[size:]
	}
	return []rune(p)
}
```
因为底层内存结构的差异，字符串到[]rune的转换必然会导致重新分配[]rune内存空间，然后依次解码并复制对应的Unicode码点值。这种强制转换并不存在前面提到的字符串和字节切片转化时的优化情况。  

**string([]rune)转换模拟实现**
```go
func runestostr(s []int32) string {
	var p[]byte
	buf := make([]byte, 3)
	for _, r := range s {
		n := utf8.EncodeRune(buf, r) //将rune类型的r转换为byte切片
		p = append(p, buf[:n]...) //将转换出来的切片添加到p的尾部
	}

	return bytetostr(p)
	//或return string(p)
}
```
因为底层内存结构的差异，字符串到[]rune的转换必然会导致重新分配[]rune内存空间，然后依次解码并复制对应的Unicode码点值。这种强制转换并不存在前面提到的字符串和字节切片转化时的优化情况。

---

字符串虽然不是切片，但是支持切片操作，不同位置的切片底层也访问的同一块内存数据（因为字符串是只读的，相同的字符串面值常量通常是对应同一个字符串常量）：  
```go
s := "hello world"  //s是字符串
hello := s[:5]      //hello是基于s的切片
world := s[6:]      //world是基于s的切片

s1 := "hello world"[:5] //s1是关于"hello world"字符串的切片。
s2 := "hello world"[6:] //s2是关于"hello world"字符串的切片。
```

***

### 1.3.3 切片（slice）
我们先看看切片的结构定义，`reflect.SliceHeader`：  
```go
type SliceHeader struct{
    Data uintptr
    Len int
    Cap int
}
```
切片的定义方式有两种：
1. 基于底层数组  
```go
var arr = [5]int{1,2,3,4,5} //底层数组
s []int   //空切片
s := []int{} //空切片
s := []int{1,2,3} //有三个元素的切片
s := arr  //s是对整个arr数组的引用
s := arr[:] //s是对整个arr数组的引用
s := arr[0:len(arr)] //s是对整个arr数组的引用
s := arr[1:4] //s是数组arr下标1到下标3的引用
```

注意`s := []int{1,2,3}`和`a := [...]int{1,2,3}`前面是切片后面是数组。
2. 使用make创建
```go
s := make([]int, 2) //长度为2的切片
s := make([]int, 2, 3) //长度为2，容量为3的切片

```

切片的遍历方式与数组相同

**添加切片元素**
内置的泛型函数append可以在切片的尾部追加N个元素：  
```go
var a []int
a = append(a, 1)
a = append(a, 2, 3, 4)
a = append(a, []int{1,2,3}...) 

```
不过要注意的是，在容量不足的情况下，append的操作会导致重新分配内存，可能导致巨大的内存分配和复制数据代价。即使容量足够，依然需要用append函数的返回值来更新切片本身，因为新切片的长度已经发生了变化。  

还可以在切片的头部添加元素：  
```go
a = append([]int{0}, a...) //在a切片的前面添加元素0
```

关于Go语言中`...`的用法：  
- 函数不定长参数的声明；例如： func sum(args ...int),这是任意个int相加的函数声明。  
- 在调用有不定长参数的函数时，可以将对应类型的切片打散作为不定长参数；例如：  
```go
var slice = []int{1,2,3,4,5,6,7}
sum(slice...)   //因为参数要求是任意个不定长的int类型，所以使用...将slice打散作为参数传递。
```

在开头一般都会导致内存的重新分配，而且会导致已有的元素全部复制1次。因此，从切片的开头添加元素的性能一般要比从尾部追加元素的性能差很多。

由于append函数返回新的切片，也就是它支持链式操作。我们可以将多个append操作组合起来，实现在切片中间插入元素：  
```go
a = append(a[:5], append([]int{666}, a[5:]...)...) //在下标为5的位置插入666
```

---

**删除切片元素**
根据要删除元素的位置有三种情况：从开头位置删除，从中间位置删除，从尾部删除。其中删除切片尾部的元素最快：  
1. 从尾部删
```go
s := []int{1,2,3,4,5,6,7,8,9}
s = s[:len(s)-1] //删除尾部的1个元素
s = s[:len(s)-n] //删除尾部的n个元素
```
2. 从头删可以直接移动数据指针
```go
s = s[1:] //删除头部的一个元素
s = s[n:] //删除头部的n个元素
```
删除开头的元素也可以不移动数据指针，但是将后面的数据向开头移动。可以用append原地完成（所谓原地完成是指在原有的切片数据对应的内存区间内完成，不会导致内存空间结构的变化）：  
```go
s = append(s[:0], s[1:]...) //从头部删除1个
s = append(s[:0], s[n:]...) //从头部删除n个
```  
还可以使用`copy`删除开头的元素：  
```go
//删除头部的一个元素
n := copy(s, s[1:])
s = s[:n]
//或可以简写为
s = s[:copy(s, s[1:])]

//删除头部的n个元素
n := copy(s, s[N:])
s = s[:n]
//或可以简写为
s = s[:copy(s, s[N:])]
```

---

**切片的内存技巧**
空数组一般很少用到，但对于切片来说，`len`为0但是`cap`不为0的切片则是非常有用的特性。当然，如果`len`和`cap`都为0的话，则变成了一个真正的空切片，虽然它不是一个`nil`值的切片，在判断一个切片是否为空时，一般通过`len`获取切片的长度来判断，一般很少将切片和`nil`值做直接的比较。

例如下面的`rmspace`函数用于删除`[]byte`中的空格。函数实现利用了0长切片的特性，实现高效而且简洁：  
```go
func rmspace(s []byte) []byte{
    b := s[:0]  //b是s的0长切片
    for _, x := range s{
        if x != ' '{
            b = append(b, 'x')
        }
    }

    return b
}
```
其实类似的根据**过滤条件**原地删除切片元素的算法都可以采用类似的方式处理(if 那里的判断)  
切片高效操作的要点是要降低内存分配的次数，尽量保证append操作不会超出cap的容量，降低触发内存分配的次数和每次分配内存大小。

---

**避免切片内存泄漏**
切片操作并不会复制底层的数据。底层的数组会被保存在内存中，直到它不在被引用
。但是有时候可能会因为一个小的内存引用而导致底层整个数组处于被使用的状态，这会延迟自动内存回收器对底层数组的回收。  
要修复这个问题，可以将感兴趣的数据复制到一个新的切片中（数据的传值是Go语言编程的一个哲学，虽然传值有一定的代价，但是换取的好处是切断了对原始数据的依赖）  

类似的问题，在删除切片元素时可能会遇到。假设切片里存放的是指针对象，那么删除末尾的元素后，被删除的元素依然被切片底层数组引用，从而不能及时导致被自动垃圾回收器回收，保险的方式是先将需要自动内存回收的元素设置为`nil`，保证自动回收器可以发现需要回收的对象，然后再进行切片的删除操作。  

当然，如果切片存在的周期很短的话，可以不用可以处理这个问题。因为如果切片本身已经可以被GC回收的话，切片对应的每个元素自然也就是可以被回收了。  

---

**切片类型的强制转换**
1. 通过`reflect.sliceHeader`更新切片头部信息实现转换，例如：  
```go
//将[]float64转换为[]int
func floattoint(f []float64) []int{
    var c []int
    aHdr := (*reflect.SliceHeader)(unsafe.Pointer(&f))
    cHdr := (*reflect.SliceHeader)(unsafe.Pointer(&c))

    *cHdr = *aHdr
    return c
}
```

